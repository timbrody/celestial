#!/usr/bin/perl -I/opt/eprints3/perl_lib

=head1 NAME

B<celestial> - harvest all new records

=head1 SYNOPSIS

B<celestial> [B<options>]

=head1 DESCRIPTION

This script downloads and stores all new records from configured repositories.

celestial forks upto 10 child processes.

=head1 OPTIONS

=over 8

=item B<--help>

Show this page.

=item B<--dryrun>

Do not write any records or touch datestamps. Will still add sets, metadata
formats and lock/unlock. Errors encountered during the harvest are also logged.

=item B<--force>

Ignore repository locks (you probably don't want to do this).

=item B<--identifier>

Harvest only the given OAI identifier.

=item B<--list>

List all configured repositories.

=item B<--nofork>

Disable forking.

=item B<--nofulltext>

Disable full-text downloads and format identification.

=item B<--repository>

Harvest only the repository given (use B<--list> to get a list of identifiers).

=item B<--missing>

Only attempt to get fulltexts where there is no record of one existing.

=item B<--all>

Perform a complete harvest.

=item B<--allfulltext>

Attempt to get fulltexts for all records, not just since the last time we did a fulltext harvest.

=item B<--verbose>

Be more verbose.

=back

=cut

use Carp;
use EPrints qw( no_check_user );
use HTML::Entities;
use POSIX 'setsid';

use strict;
use warnings;
use encoding 'utf8';
use FindBin;
use lib "$FindBin::Bin/../lib";

binmode(STDOUT,":utf8");

use POSIX qw/:sys_wait_h strftime/;

use vars qw($VERSION $MAX_HARVESTERS $ADMINEMAIL $HTTP_TIMEOUT $DEBUG $GRANULARITY $JAVA $DROID $DROID_SIG $MAX_FILE_SIZE);

$VERSION = '3.02';
$HTTP_TIMEOUT = 300; # In seconds
$MAX_FILE_SIZE = 1024*1024*10; # 10MB

$JAVA = '/usr/bin/java';
$DROID = '/home/celestial/share/DROID/DROID.jar';
$DROID_SIG = '/home/celestial/share/DROID/DROID_SignatureFile.xml';

use Getopt::Long;
use Pod::Usage;

use HTTP::OAI;
use HTTP::OAI::Metadata::OAI_DC;
use Celestial;
use Date::Parse;
use File::Temp;
use XML::LibXML;
use XML::LibXML::XPathContext;

die if $HTTP::OAI::Harvester::VERSION < 3.12;

use constant {
	WITH_DAYS => 1,
	WITH_SECONDS => 2
};

# Disable eval() to allow easier debug
#$HTTP::OAI::UserAgent::USE_EVAL = 0;
#$HTTP::OAI::Response::USE_EVAL = 0;

our $opt_verbose;
our $opt_identifier;
our $opt_missing;
my( $opt_list, $opt_repository, $opt_help, $opt_cfg, $opt_fork, $opt_force, $opt_fulltext, $opt_dryrun, $opt_allfulltext, $opt_migrate, $opt_all, $opt_daemon );
$opt_dryrun = 0;
$opt_verbose = 0;
$opt_fork = 1;
$opt_fulltext = 1;

GetOptions(
	'verbose+' => \$opt_verbose,
	'list' => \$opt_list,
	'repository=s' => \$opt_repository,
	'help' => \$opt_help,
	'cfg=s' => \$opt_cfg,
	'fork!' => \$opt_fork,
	'identifier=s' => \$opt_identifier,
	'force' => \$opt_force,
	'fulltext!' => \$opt_fulltext,
	'missing' => \$opt_missing,
	'dryrun' => \$opt_dryrun,
	'allfulltext' => \$opt_allfulltext,
	'migrate' => \$opt_migrate,
	'all' => \$opt_all,
	'daemon' => \$opt_daemon,
) or pod2usage("Invalid argument");

pod2usage(1) if $opt_help;

if( defined($opt_repository) && $opt_repository =~ /\D/ ) {
	pod2usage("Repository argument must be numeric.");
}

$DEBUG = $opt_verbose;

if( $opt_daemon )
{
	exit if fork();
	chdir('/');
	setsid();
	open(STDOUT, ">", "/tmp/celestial.log") or die "Error writing to log";
	open(STDERR, ">>", "/tmp/celestial.log") or die "Error writing to log";
}

use HTTP::OAI::Debug;
if( $opt_verbose > 2 )
{
	HTTP::OAI::Debug::level( '+' );
}

my $roar = EPrints->new->repository( "roar" );

my $cfg  = Celestial::Config->new( $opt_cfg );

my $dbh = Celestial::DBI->connect() or die "Unable to connect to database: $!";

$ADMINEMAIL = $dbh->adminEmail or die "No adminEmail configured (required to harvest)\n";
$MAX_HARVESTERS = $dbh->maxHarvesters || 10;

$JAVA = $cfg->get_conf( "java" ) || $JAVA;
$DROID = $cfg->get_conf( "droid", "jar" ) || $DROID;
$DROID_SIG = $cfg->get_conf( "droid", "signature" ) || $DROID_SIG;

# Set up the environment
$0 = "celestial-harvest";

# Current number of active harvesters
my $c = 0;

if( $opt_list ) {
	$roar->dataset( "celestial" )->search->map(sub {
		my( undef, undef, $repo ) = @_;

		print $roar->xhtml->to_text_dump( $repo->render_citation( "brief" ) ), "\n";
	});
	exit;
}

my %CHILDREN;

$SIG{'USR2'} = sub {
	print "(parent) Waiting for following harvesters to finish (pid/identifier):\n";

	while( my ($pid,$repo) = each %CHILDREN ) {
		printf("\t%d\t%s\n", $pid, $repo->id);
	}
};

my @repos = $roar->dataset( "celestial" )->search->slice;

# For each repository spawn a child that will update that repository
foreach my $repo (@repos)
{
	if( defined($opt_repository) && $repo->id != $opt_repository )
	{
#		print "(parent) " . $repo->id . " ignored due to command line argument\n" if $opt_verbose;
		next;
	}

	if( scalar keys %CHILDREN >= $MAX_HARVESTERS )
	{
		my $pid = wait();
		my $r = delete $CHILDREN{$pid};
		print "(parent) [" . $r->id . "] $pid finished\n" if $opt_verbose;
	}

	my $pid = fork();
	die "fork failed: $!" if !defined $pid;

	# parent
	if( $pid )
	{
		$CHILDREN{$pid} = $repo;
	}
	# child
	else
	{
		$0 = "celestial-harvest-".$repo->id;

		# reconnect to the databases after forking
		$roar->get_database->connect;
		$dbh = Celestial::DBI->connect;

		if( !$repo->obtain_lock( $$ ) )
		{
			if( !$opt_force )
			{
				die "[" . $repo->id . "] couldn't obtain lock, ignoring\n";
			}
			$repo->release_lock;
			$repo->obtain_lock( $$ );
		}
		update_repository($dbh,
			repository=>$repo,
			adminEmail=>$ADMINEMAIL
		);
		$repo->release_lock;
		exit;
	}
}

while( scalar keys %CHILDREN )
{
	print "(parent) Waiting for following harvesters to finish (pid/identifier):\n" if $opt_verbose;

	while( my ($pid,$repo) = each %CHILDREN ) {
		printf("\t%d\t%s\n", $pid, $repo->id) if $opt_verbose;
	}

	my $pid = wait();
	die "No child processes?!" if $pid == -1;
	my $r = delete $CHILDREN{$pid};
	print "(parent) [" . $r->id . "] $pid finished: $?\n" if $opt_verbose;
}

#print "(parent) Finished harvesting, updating cardinality\n" if $opt_verbose;

#foreach my $repo ($dbh->listRepositories) {
#	foreach my $mdf ($repo->listMetadataFormats) {
#		my $tblname = $mdf->table;
#		my $c = 0;
#		my $s = 0;
#		if( $dbh->table_exists($tblname) ) {
#			$mdf->cardinality( $dbh->cardinality( $tblname ));
#			$mdf->storage( $dbh->storage( $tblname ));
#			$mdf->commit;
#		}
#	}
#}

# Check for really broken repositories, and lock them
#unless( $opt_dryrun ) {
#	my %repos;
#	my $sth = $dbh->prepare("SELECT repository,lastHarvest>NOW() - INTERVAL 14 DAY FROM MetadataFormats WHERE lastAttempt is not Null AND lastHarvest is not Null AND lastAttempt > NOW() - INTERVAL 14 DAY");
#	$sth->execute;
#	while(my ($id,$not_updated) = $sth->fetchrow_array) {
#		$repos{$id} = $not_updated unless $repos{$id};
#	}
#	foreach my $id ( keys %repos ) {
#		next if $repos{$id};
#		my $repo = $dbh->getRepository($id) or next;
#		print "(parent) Permanently locking $id (".$repo->identifier.")\n" if $opt_verbose;
#		$dbh->lock($id,0);
#	}
#}

$dbh->disconnect;

sub update_repository {
	my $dbh = shift;
	my %args = @_;
	my $repo = $args{repository};
	my $adminEmail = $args{adminEmail} || '';
	my $startTime = $dbh->now();

	my ($lastURL, $lastError, $lastResponse);

	my $ha = new HTTP::OAI::Harvester(baseURL=>$repo->value( "url" ),debug=>$DEBUG);
	$ha->agent("Celestial/$VERSION");
	$ha->timeout($HTTP_TIMEOUT);
	$ha->from($adminEmail);
	{ # scopy $stime
		my $stime;
		$ha->delay(sub {
			no warnings; # last time and stime will be undefined
			my $wait = $_[0] - $stime;
			$wait = .5 if $wait < .5;
			$wait = 60 if $wait > 60;
			select(undef,undef,undef,$wait);
			$stime = time();
			return 0;
		});
	}

	$repo->set_status( "Identify" ); $repo->commit;

	my $identify = $ha->Identify;
	if( $identify->is_error ) {
		my $message = "Unable to get Identify: " . $identify->code . " (" . $identify->message . ")\n".$identify->request->uri;
		warn "[" . $repo->id . "] " . $message if $opt_verbose;
		$repo->set_value( "messages", [] );
		$repo->add_message( "error", $repo->{session}->xml->create_text_node(
			$message
		) );
		$repo->commit;
		return;
	}
	$ha->repository->version( $identify->version );

	$GRANULARITY = WITH_DAYS;
	if( $identify->granularity and
			$identify->granularity =~ /YYYY-MM-DDThh:mm:ssZ/i )
	{
		$GRANULARITY = WITH_SECONDS;
	}

# warn $repo->identifier .": Protocol version " . $ha->repository->version . "\n";

	# cache Identify response
#	$repo->Identify( $identify->toDOM->toString );
#	$repo->commit;

	my $table = $repo->sql_set_table_name;
	my $tmp_table = $table . "_$$";
	my $new_table = $table . "_new";
	my $old_table = $table . "_old";

	$dbh->do("CREATE TABLE IF NOT EXISTS $table $Celestial::Schema::SET");
	$dbh->do("CREATE TEMPORARY TABLE $tmp_table $Celestial::Schema::SET");
	$dbh->do("DROP TABLE IF EXISTS $new_table");
	$dbh->do("CREATE TABLE $new_table $Celestial::Schema::SET");

	$repo->set_status( "ListSets" ); $repo->commit;

	my $ls = $ha->ListSets();
	while( my $set = $ls->next ) {
		$dbh->do("INSERT IGNORE $new_table (spec,spec_md5,name) VALUES (?,MD5(?),?)",{},
			$set->setSpec,
			$set->setSpec,
			$set->setName
		);
	}
	if( $ls->is_error ) {
		$dbh->do("DROP TABLE $new_table");
		my $lastError = "[" . $repo->id ."] Error requesting ListSets: " . $ls->code . " (" . $ls->message . ")\n";
		warn ($lastError) if $opt_verbose;
	}
	else
	{
		$dbh->do("INSERT INTO $new_table (setid,spec,spec_md5,name) SELECT $table.setid,$tmp_table.spec,$tmp_table.spec_md5,$tmp_table.name FROM $tmp_table LEFT JOIN $table USING(setid)");
		$dbh->do("RENAME TABLE $table TO $old_table, $new_table TO $table");
		$dbh->do("DROP TABLE $old_table");
	}

	$repo->set_status( "ListMetadataFormats" ); $repo->commit;

	my $lmdf = $ha->ListMetadataFormats();
	if( $lmdf->is_error ) {
		my $lastError = "[" . $repo->id . "] Error requesting ListMetadataFormats: " . $lmdf->code . " (" . $lmdf->message . ")\n";
		warn ($lastError)
			if $opt_verbose;
#		$dbh->addRepositoryError($repo,
#			$lmdf->request->uri,
#			$lastError,
#			$lmdf->content
#		);
		return;
	}

	my $harvest_func = \&harvest_ListRecords;
	if( $repo->is_set( "method" ) && $repo->value( "method" ) eq "GetRecord" )
	{
		$harvest_func = \&harvest_GetRecord;
	}

	my %mdfs;
	foreach my $mdf ($lmdf->metadataFormat)
	{
		$mdfs{$mdf->metadataPrefix} = $mdf;
	}

	my @mdfs;
	foreach my $format (@{$repo->value( "formats" )})
	{
		my $mdf = delete $mdfs{$format->{prefix}};
		next if !defined $mdf;
		$format->{prefix} = $mdf->metadataPrefix;
		$format->{schema} = $mdf->schema;
		$format->{namespace} = $mdf->metadataNamespace;
		push @mdfs, $format;
	}
	foreach my $mdf (values %mdfs)
	{
		push @mdfs, {
			prefix => $mdf->metadataPrefix,
			schema => $mdf->schema,
			namespace => $mdf->metadataNamespace,
		};
	}

	$repo->set_value( "formats", \@mdfs );
	$repo->commit;

	my $oai_dc;
	foreach my $format ($repo->formats)
	{
		$oai_dc = $format, last if $format->{prefix} eq "oai_dc";
	}
	if( !defined $oai_dc )
	{
		warn "[".$repo->id."] No oai_dc available\n"
			if $opt_verbose;
		return;
	}

	my $last_harvest = timestamp($oai_dc->{harvest});
	my $last_token = $oai_dc->{token};

	my $freq = $repo->value( "frequency" );
	my $full_freq = $repo->value( "full_frequency" );

	if( $full_freq )
	{
		my $ok = $dbh->selectall_arrayref("SELECT ? + INTERVAL ? DAY < NOW()",{},$last_harvest,$full_freq);
		undef $last_harvest if $ok;
	}
	if( $freq && $last_harvest )
	{
		my $ok = $dbh->selectall_arrayref("SELECT ? + INTERVAL ? DAY < NOW()",{},$last_harvest,$freq);
		return if !$ok;
	}

	if( $opt_all )
	{
		$last_harvest = undef;
	}

	my $latest_harvest = EPrints::Time::get_iso_timestamp();

	$repo->set_status( "ListRecords" ); $repo->commit;

	my( $last_url, $last_error, $last_response ) = &$harvest_func($dbh,
		harvestAgent => $ha,
		repository => $repo,
		metadataFormat => $oai_dc,
		from => $last_harvest,
		resumptionToken => $last_token
	);

	if( $last_error )
	{
		my $message = "$last_error - $last_url";
		$repo->add_message( "error", $repo->{session}->xml->create_text_node(
			$message
		) );
		warn "(".$repo->id.") Error in harvest: $message\n"
			if $opt_verbose;
		$repo->commit();
	}
	else
	{
		$oai_dc->{harvest} = $latest_harvest;
		$oai_dc->{full_harvest} = $latest_harvest if !defined $last_harvest;
		my $mdfs = EPrints::Utils::clone( $repo->value( "formats" ) );
		for(@$mdfs)
		{
			$_ = $oai_dc if $_->{prefix} eq 'oai_dc';
		}
		$repo->set_value( "formats", $mdfs );
		$repo->commit();

		my $ok = eval { harvest_Fulltext( $dbh,
			harvestAgent => $ha,
			repository => $repo,
			from => ($opt_allfulltext ? undef : $latest_harvest)
		) };

		# clear error messages
		$repo->set_value( "messages", [] );

		if( $@ )
		{
			$repo->add_message( "error", $repo->{session}->xml->create_text_node(
				$@
			) );
		}

		warn "(".$repo->id.") finished harvest started at $latest_harvest\n"
			if $opt_verbose;

		$repo->commit();
	}

	1;
}

sub harvest_ListRecords {
	my( $dbh, %args ) = @_;
	my( $ha, $repo, $mdf, $from, $set, $token ) = @args{qw(
		harvestAgent
		repository
		metadataFormat
		from
		set
		resumptionToken
	)};

	my $tmp_table = "listrecords_$$";

	# for full harvests, keep a note of new records so we can remove records
	# that no longer exist
	if( !defined $from )
	{
		$dbh->do("DROP TEMPORARY TABLE IF EXISTS $tmp_table");
		$dbh->do("CREATE TEMPORARY TABLE $tmp_table (recordid INT UNSIGNED NOT NULL, PRIMARY KEY(recordid))");
	}

	my $table = $mdf->sql_table_name;

	$dbh->do("CREATE TABLE IF NOT EXISTS $table $Celestial::Schema::RECORD");

	my $set_table = "set_record_".$repo->id;

	$dbh->do("CREATE TABLE IF NOT EXISTS $set_table $Celestial::Schema::SET_RECORD");

	my $spec_table = "set_".$repo->id;

	my $sth_exists = $dbh->prepare("SELECT recordid FROM $table WHERE identifier_md5=MD5(?)");
	my $sth_set_lookup = $dbh->prepare("SELECT setid FROM $spec_table WHERE spec_md5=MD5(?)");

	# update/initialize the cardinality
	$mdf->{cardinality} = $dbh->selectall_arrayref("SELECT COUNT(*) FROM $table WHERE status is Null")->[0]->[0];
	$mdf->commit;

	my $cb = sub {
		my( $rec, $lr ) = @_;

		$repo->set_status( $lr->request ? "".$lr->request->uri." [".$rec->identifier."]" : "Unknown URI" ); $repo->commit;

		printf("%s => %s\n", $rec->identifier, $rec->datestamp) if $opt_verbose > 1;
		return if $opt_dryrun;

		my $accession = $rec->datestamp;
		$accession = $dbh->now() if !$accession;

		my $header = $rec->header->dom->toString;
		my $metadata = $rec->metadata;
		$metadata = $metadata->toString if defined $metadata;
		my $about;
		for($rec->about)
		{
			$about .= $_->dom->documentElement->toString;
		}
		$about = "<?xml version='1.0'?>\n<about>$about</about" if defined $about;

		my $id;

		$sth_exists->execute( $rec->identifier );
		if( defined(my $row = $sth_exists->fetch) )
		{
			$id = $row->[0];
			$dbh->do("UPDATE $table
				SET
					datestamp=NOW() AND
					status=? AND
					header=COMPRESS(?) AND
					metadata=COMPRESS(?) AND
					about=COMPRESS(?)
				WHERE
					recordid=$id",{},
				$rec->status,
				$header,
				$metadata,
				$about
			);
		}
		else
		{
			my $sth = $dbh->prepare("INSERT INTO $table
				(datestamp,accession,identifier,identifier_md5,status,header,metadata,about)
				VALUES (NOW(),?,?,MD5(?),?,COMPRESS(?),COMPRESS(?),COMPRESS(?))");
			$sth->execute(
				$accession,
				$rec->identifier,
				$rec->identifier,
				$rec->status,
				$header,
				$metadata,
				$about
			);
			$id = $sth->{'mysql_insertid'}
				or die "missing mysql_insertid";

			$mdf->{cardinality}++;
			$mdf->commit;
		}

		if( !defined $from )
		{
			$dbh->do("INSERT IGNORE INTO $tmp_table (recordid) VALUES ($id)");
		}

		$dbh->do("DELETE FROM $set_table WHERE recordid=$id");
		foreach my $spec ($rec->header->setSpec)
		{
			next if !defined $spec;
			my @parts = grep { length($_) } split /:/, $spec;
			foreach my $i (0..$#parts)
			{
				$spec = join ':', @parts[0..$i];
				$sth_set_lookup->execute( $spec );
				my( $setid ) = $sth_set_lookup->fetchrow_array or next;
				$dbh->do("INSERT IGNORE INTO $set_table (recordid,setid) VALUES ($id,$setid)");
			}
		}
	};

	WITHOUT_TOKEN:
	my $lr = defined($token) ? 
		$ha->ListRecords(
			resumptionToken=>$token,
			onRecord => $cb,
		) :
		$ha->ListRecords(
			force=>1, # Force bad metadata prefixes
			metadataPrefix=>$mdf->{prefix},
			from=>datestamp($from, $GRANULARITY == WITH_SECONDS),
			set=>$set,
			onRecord => $cb,
		);

	$mdf->{token} = undef;
	$mdf->commit; # update cardinality

	if( $lr->is_error ) {
		# $lr may be an HTTP::Response
		my $error = eval { ($lr->errors)[0] };
		if( defined($token) && defined($error) && $error->code eq "badResumptionToken" )
		{
			undef $token;
			goto WITHOUT_TOKEN;
		}
		# save the resumptionToken
		my $ctoken = eval { $lr->resumptionToken->resumptionToken };
		if( defined $ctoken && ( !defined $token || $token ne $ctoken ) )
		{
			$mdf->{token} = $ctoken;
			$mdf->commit;
		}
		return(
			($lr->request ? $lr->request->uri : 'Unknown URI!'),
			"(" . $repo->id . "/". $mdf->{prefix} . ") Error requesting ListRecords: " . $lr->code . " (" . $lr->message . ")\n",
			$lr->content
		);
	}

	# if this was a full-harvest delete any disappeared records
	if( !defined $from )
	{
		my $sth = $dbh->prepare("SELECT recordid FROM $table LEFT JOIN $tmp_table USING(recordid) WHERE $tmp_table.recordid is Null");
		$sth->execute;
		while(my ($id) = $sth->fetchrow_array)
		{
			$mdf->{cardinality}--;
			delete_record( 
				repository => $repo,
				oai_dc => $mdf,
				dbh => $dbh,
				id => $id
			);
		}
		$mdf->commit;
	}

	(undef,undef,undef);
}

sub delete_record
{
	my( %opts ) = @_;

	my $table = $opts{oai_dc}->sql_table_name;
	my $set_record_table = $opts{repository}->sql_set_record_table_name;
	my $fulltext_table = $opts{repository}->sql_fulltext_table_name;
	my $id = $opts{id};

	$opts{dbh}->do("DELETE FROM $table WHERE recordid=$id");
	$opts{dbh}->do("DELETE FROM $set_record_table WHERE recordid=$id");
	$opts{dbh}->do("DELETE FROM $fulltext_table WHERE recordid=$id");
}

sub harvest_GetRecord {
	my( $dbh, %args ) = @_;
	my( $ha, $repo, $mdf, $from, $set ) = @args{qw(
		harvestAgent
		repository
		metadataFormat
		from
		set
	)};

	if( defined($opt_identifier) ) {
		my $r = $ha->GetRecord(
			identifier=>$opt_identifier,
			metadataPrefix=>$mdf->metadataPrefix
		);
		if( $r->is_error ) {
			return ($r->request->uri,
			"(" . $repo->identifier . "/" . $mdf->metadataPrefix . ") Error requresting GetRecord: " . $r->code . " (" . $r->message . ")\n",
				$r->content,
			);
		}
		my $rec = $r->next || return (undef,undef,undef);
		printf("%s => %s\n", $rec->identifier, $rec->datestamp) if $opt_verbose > 1;
		$mdf->addRecord($rec);

		return (undef,undef,undef);
	}
	my $li = $ha->ListIdentifiers(from=>$from,set=>$set);

	while( my $id = $li->next ) {
		my $rec = $ha->GetRecord(
			identifier=>$id->identifier,
			metadataPrefix=>$mdf->metadataPrefix,
		);
		if( $rec->is_error ) {
			my $error = "(" . $repo->identifier . "/" . $mdf->metadataPrefix . ") Error retrieving GetRecord for " . $id->identifier . ": " . $rec->code . " (" . $rec->message . ")";
			warn($error);
			$dbh->addError($mdf,$error,$rec->content);
			next;
		}
		$rec = $rec->next || next;
		printf("%s => %s\n", $rec->identifier, $rec->datestamp) if $opt_verbose > 1;
		$mdf->addRecord($rec);
# Add a small delay so we don't overrun the repository
		select(undef,undef,undef,0.25);
	}

	if( $li->is_error ) {
		return(
			$li->request->uri,
			"(" . $repo->identifier . "/" . $mdf->metadataPrefix . ") Error requesting ListIdentifiers: " . $li->code . " (" . $li->message . ")\n",
			$li->content
		);
	}

	(undef,undef,undef);
}

sub harvestSetMembership_1_1 {
	my ($dbh, %args) = @_;
	my $ha = $args{-harvestAgent};
	my $repo = $args{-repository};
	my $from = $args{-from};

	my $sth = $dbh->prepare("SELECT id,setSpec FROM Sets WHERE repository=?");
	$sth->execute($repo->id);

	my @mdfs = $dbh->listMetadataFormats($repo);

	# For each Set in the repository
	while( my ($setid,$setSpec) = $sth->fetchrow_array ) {
# warn $repo->identifier . ": Requesting set $setSpec (" . ($from || 'all') . ")\n";
		# Request a list of records in that set
		my $li = $ha->ListIdentifiers(
			from=>datestamp($from, $GRANULARITY == WITH_SECONDS),
			set=>$setSpec
		);
		if( $li->is_error ) {
			return(
				$li->request->uri,
				"(" . $repo->identifier . "/" . $setSpec . ") Error requesting ListIdentifiers: " . $li->code . " (" . $li->message . ")\n",
				$li->content
			);
		}
		# For each item in the set
		while( my $header = $li->next ) {
			if( $header->is_error ) {
				return(
					$header->request->uri,
					"(" . $repo->identifier . "/" . $setSpec . ") Error requesting ListIdentifiers: " . $header->code . " (" . $header->message . ")\n",
					$header->content
				);
			}
			# For each metadata format ...
			foreach my $mdf (@mdfs) {
				my $id = $dbh->getId($mdf,$header->identifier) || next;
				# ... and each item record
				my $rec = $dbh->getRecord($mdf,$id);
				if( addRecordSetSpec($rec,$setSpec) ) {
					$mdf->updateRecord(
						id=>$id,
						record=>$rec
					);
				}
			}
		}
	}
	$sth->finish;
	(undef,undef,undef);
}

sub harvest_Fulltext
{
	return unless $opt_fulltext;
	my( $dbh, %args ) = @_;
	my( $ha, $repo, $from ) = @args{qw( harvestAgent repository from )};

	$repo->set_status( "Fulltext" ); $repo->commit;

	my $pronom_table = $repo->sql_pronom_table_name;
	my $table = $repo->sql_fulltext_table_name;

	$dbh->do("CREATE TABLE IF NOT EXISTS $table $Celestial::Schema::FULLTEXT");

	my $ft = Celestial::FullText->new(
		repository => $repo,
		dbh => $dbh,
		harvestAgent => $ha,
	);

	$Celestial::FullText::MAX_FILE_SIZE = $MAX_FILE_SIZE;
	$Celestial::FullText::DEBUG = $opt_verbose;
		
	my $sth;
	if( $from )
	{
		$sth = $dbh->prepare("SELECT recordid,identifier,accession FROM record_".$repo->id."_oai_dc WHERE datestamp>=?");
		$sth->execute( $from );
	}
	else
	{
		$sth = $dbh->prepare("SELECT recordid,identifier,accession FROM record_".$repo->id."_oai_dc");
		$sth->execute;
	}

	while( my ($id, $identifier, $accession) = $sth->fetchrow_array )
	{
		# Skip if the record already has some full-texts recorded
		next if $opt_missing && ($dbh->selectrow_array( "SELECT 1 FROM $table WHERE recordid=$id" ));
		
		# Remove existing formats for this record
		$dbh->do("DELETE FROM $table WHERE recordid=$id");

		my @formats = $ft->formats( $id );
		warn "[".$repo->id."] full-text for [$id] ($identifier) = ".@formats."\n"
			if $opt_verbose;

		foreach my $fmt ( @formats )
		{
			my $ds = $accession;
			if( $fmt->date )
			{
				my $t = Date::Parse::str2time( $fmt->date );
				if( $t )
				{
					$ds = strftime("%Y%m%d%H%M%S", gmtime($t));
				}
			}
			my $url = $fmt->url;
			my $ct = $fmt->mime_type;
			my @types;
			eval { @types = run_file( "$fmt" ) };
			if( $@ )
			{
				warn sprintf("There was a problem running droid for %s (%s): %s\n", $identifier, $fmt, $@);
				@types = ();
			}
			@types = ([undef,'Unknown']) unless @types;
			foreach my $t (@types)
			{
				warn sprintf("Got format %s for %s\n", $t->[1], $url) if $opt_verbose;
				$dbh->do("INSERT IGNORE INTO pronom (puid, name) VALUES (?,?)",{},@$t) if defined $t->[0];
				my( $pronomid ) = $dbh->selectrow_array("SELECT pronomid FROM pronom WHERE puid=?",{},$t->[0]);
				$dbh->do("INSERT INTO $table (recordid,datestamp,url,mimetype,pronomid) VALUES (?,?,?,?,?)",{},
					$id,
					$ds,
					$url,
					$ct,
					$pronomid
				);
			}
		}
	}
	$sth->finish;

	warn "[".$repo->id."] full-text harvest finished\n"
		if $opt_verbose;

	return $ft;
}

sub getDcRecord
{
	my( $mdf, $id ) = @_;

	my $rec = $mdf->getRecord( $id ) or return;

	return if $rec->header->is_deleted;

	if( not $rec->metadata )
	{
		warn sprintf("%s doesn't contain any metadata\n", $rec->identifier);
		return;
	}

	my $dc = HTTP::OAI::Metadata::OAI_DC->new();
	$rec->metadata->set_handler(
			HTTP::OAI::SAXHandler->new( # Required to supply Text
				Handler => $dc
				));
	$rec->metadata->generate;
	$rec->metadata( $dc );

	return $rec;
}

sub getMetsRecord
{
	my( $mdf, $id ) = @_;

	my $rec = $mdf->getRecord( $id ) or return;
	
	return if $rec->header->is_deleted or not $rec->metadata;

	$rec->metadata( HTTP::OAI::Metadata::METS->new( dom => $rec->metadata->dom ));

	return $rec;
}

# If the record already has the setSpec, return 0, otherwise add the setSpec and return 1
sub addRecordSetSpec {
	my ($rec, $setSpec) = @_;
	for ($rec->header->setSpec) {
		return 0 if $_ eq $setSpec;
	}
# print "Adding $setSpec to ", $rec->identifier, "\n";
	$rec->header->setSpec($setSpec);
	return 1;
}

sub datestamp {
	my $ds = shift || return undef;
	my $wt = shift;
	$ds =~ s/\D//g;
	my $r = '';
	if( $ds =~ s/^(\d{4})(\d{2})(\d{2})// ) {
		$r = "$1-$2-$3";
	} else {
		die "Cannot extract datestamp from $ds";
	}
	if( $wt and $ds =~ s/^(\d\d)(\d\d)(\d\d)$// ) {
		$r .= "T$1:$2:$3Z";
	}
	return $r;
}

sub timestamp {
	my $ts = shift || return undef;
	if( $ts =~ /^(\d{4})\D?(\d{2})\D?(\d{2})\D?(\d{2})\D?(\d{2})\D?(\d{2})/ ) {
		return "$1-$2-$3T$4:$5:$6Z";
	} else {
		die "Cannot extract timestamp from $ts";
	}
}

sub run_file {
	my( $fn ) = @_;

	my $type = `file -bz $fn`; # brief, look-inside compressed
	chomp($type);

	return () if !$type;
	
	$type =~ s/\(.+$//; # strip commentary
	$type =~ s/^(CDF V2 Document).*/$1/; # CDFs contain detailed info, not just type :-(
	$type =~ s/^.*(HTML document).*/$1/; # as do HTML documents

	my $type_id = "file:".Digest::MD5::md5_base64( $type );

	return [ $type_id, $type ];
}

sub run_droid {
	my $fn = shift;
	my $tmp = File::Temp->new( UNLINK => 1 );
	my $cmd = "$JAVA -ms20m -jar $DROID -s $DROID_SIG -o $tmp -f XML -l=$fn";
	my $r = system("$cmd >/dev/null 2>&1");
	if( $r != 0 )
	{
		die("Error running $cmd: $?");
	}
	my $doc = XML::LibXML->new->parse_file("$tmp.xml");
	unlink("$tmp.xml");
	my $xc = XML::LibXML::XPathContext->new( $doc );
	$xc->registerNs('rc','http://www.nationalarchives.gov.uk/pronom/FileCollection');
	my @formats;
	for($xc->findnodes("//rc:FileFormatHit")) {
		my %attr;
		foreach my $valnode (grep { $_->nodeType == XML_ELEMENT_NODE } $_->childNodes)
		{
			$attr{ $valnode->nodeName } = $valnode->textContent;
		}
		my $fmt = defined($attr{ 'Version' }) ?
			sprintf("%s (%s)",
					$attr{ 'Name' },
					$attr{ 'Version' }
				   ) :
				$attr{ 'Name' };

		push @formats, [
			$attr{ 'PUID' },
			$fmt,
			];
		#warn "FORMAT: $fn => ", join(',',map { $_ || '(null)' } @{$formats[$#formats]}), "\n";
	}
	return @formats;
}

